import JSZip from 'jszip';

/**
 * Tarball Builder for Sanity Import Packages
 * Creates .tar.gz packages containing NDJSON content + placeholder assets
 */

export interface AssetPlaceholder {
  _id: string;
  _type: 'sanity.imageAsset' | 'sanity.fileAsset';
  url: string;
  originalFilename: string;
  mimeType: string;
  size: number;
  metadata?: {
    dimensions?: {
      width: number;
      height: number;
      aspectRatio: number;
    };
    hasAlpha?: boolean;
    isOpaque?: boolean;
  };
}

export interface TarballOptions {
  includeAssets?: boolean;
  assetPlaceholders?: AssetPlaceholder[];
  includeReadme?: boolean;
  packageName?: string;
}

/**
 * Generates placeholder image assets for content blocks
 * These can be replaced with real images after import
 */
function generatePlaceholderAssets(contentBlocks: any[]): AssetPlaceholder[] {
  const assets: AssetPlaceholder[] = [];
  let assetCounter = 1;

  // Recursively find image references in content blocks
  function findImageRefs(obj: any, path: string = '') {
    if (typeof obj !== 'object' || obj === null) return;

    for (const [key, value] of Object.entries(obj)) {
      const currentPath = path ? `${path}.${key}` : key;

      if (key === 'asset' && typeof value === 'object' && value !== null) {
        // Found an asset reference - generate placeholder
        const assetId = `image-${assetCounter++}`;
        const placeholder: AssetPlaceholder = {
          _id: assetId,
          _type: 'sanity.imageAsset',
          url: `https://via.placeholder.com/800x600/e5e7eb/374151?text=Placeholder+${assetCounter - 1}`,
          originalFilename: `placeholder-${assetCounter - 1}.jpg`,
          mimeType: 'image/jpeg',
          size: 45000, // Approximate size
          metadata: {
            dimensions: {
              width: 800,
              height: 600,
              aspectRatio: 800/600
            },
            hasAlpha: false,
            isOpaque: true
          }
        };
        
        assets.push(placeholder);
        
        // Update the reference to point to our placeholder
        if (typeof value === 'object') {
          (value as any)._ref = assetId;
        }
      } else if (typeof value === 'object') {
        findImageRefs(value, currentPath);
      }
    }
  }

  contentBlocks.forEach(block => findImageRefs(block));
  return assets;
}

/**
 * Creates a README file explaining the package contents
 */
function createPackageReadme(packageName: string, contentInfo: any): string {
  const date = new Date().toLocaleDateString('da-DK');
  
  return `# ${packageName}

Generated on: ${date}
Generator: SEO Page Generator for ElPortal.dk

## Package Contents

### Content Files
- \`content.ndjson\` - Main content document for Sanity import
- \`assets.ndjson\` - Placeholder image assets (if included)

### Content Information
- **Topic**: ${contentInfo.topic || 'N/A'}
- **Keywords**: ${(contentInfo.keywords || []).join(', ') || 'N/A'}
- **Content Goal**: ${contentInfo.contentGoal || 'N/A'}
- **Language**: ${contentInfo.language || 'Danish (da)'}
- **Content Blocks**: ${contentInfo.blockCount || 0} blocks

### Import Instructions

1. **Sanity CLI Import**:
   \`\`\`bash
   sanity dataset import content.ndjson production --replace
   \`\`\`

2. **Asset Import** (if assets.ndjson exists):
   \`\`\`bash
   sanity dataset import assets.ndjson production --replace
   \`\`\`

### Asset Placeholders

This package includes placeholder images that should be replaced with real assets:
- All placeholder images use \`via.placeholder.com\` URLs
- Replace these with actual images from your asset library
- Update asset references in Sanity Studio after import

### Schema Requirements

Ensure your Sanity schema includes the following document types:
- \`page\` (or your custom page type)
- \`textBlock\`, \`imageBlock\`, etc. (based on your content blocks)

### Generated Structure

The content follows ElPortal.dk's schema conventions:
- Danish language optimization (\`da\`)
- SEO-friendly slugs with proper Danish character handling
- Structured content blocks for flexibility
- Metadata for programmatic SEO

---

**Generated by SEO Page Generator**
Internal tool for ElPortal.dk content creation
`;
}

/**
 * Creates a .tar.gz package with NDJSON and assets
 * Uses JSZip to create the archive (browser-compatible)
 */
export async function createTarballPackage(
  ndjson: string,
  contentInfo: {
    topic?: string;
    keywords?: string[];
    contentGoal?: string;
    language?: string;
    title?: string;
  },
  options: TarballOptions = {}
): Promise<Blob> {
  const zip = new JSZip();
  const packageName = options.packageName || 'seo-content-package';

  // Add main content file
  zip.file('content.ndjson', ndjson);

  // Generate and add placeholder assets if requested
  if (options.includeAssets !== false) {
    try {
      // Parse NDJSON to extract content blocks
      const contentLines = ndjson.split('\n').filter(line => line.trim());
      const documents = contentLines.map(line => JSON.parse(line));
      
      // Find all content blocks
      const allContentBlocks = documents.reduce((blocks, doc) => {
        if (doc.contentBlocks && Array.isArray(doc.contentBlocks)) {
          return [...blocks, ...doc.contentBlocks];
        }
        return blocks;
      }, []);

      // Generate placeholder assets
      const placeholderAssets = generatePlaceholderAssets(allContentBlocks);
      
      if (placeholderAssets.length > 0) {
        const assetsNDJSON = placeholderAssets
          .map(asset => JSON.stringify(asset))
          .join('\n');
        
        zip.file('assets.ndjson', assetsNDJSON);
      }
    } catch (error) {
      console.warn('Failed to generate placeholder assets:', error);
    }
  }

  // Add README if requested
  if (options.includeReadme !== false) {
    const contentBlocks = ndjson.split('\n').filter(line => line.trim());
    const readme = createPackageReadme(packageName, {
      ...contentInfo,
      blockCount: contentBlocks.length
    });
    
    zip.file('README.md', readme);
  }

  // Add custom assets if provided
  if (options.assetPlaceholders && options.assetPlaceholders.length > 0) {
    const customAssetsNDJSON = options.assetPlaceholders
      .map(asset => JSON.stringify(asset))
      .join('\n');
    
    zip.file('custom-assets.ndjson', customAssetsNDJSON);
  }

  // Generate the archive
  try {
    const blob = await zip.generateAsync({
      type: 'blob',
      compression: 'DEFLATE',
      compressionOptions: {
        level: 6
      }
    });

    return blob;
  } catch (error) {
    console.error('Failed to create tarball package:', error);
    throw new Error('Failed to create package archive');
  }
}

/**
 * Downloads the tarball package to user's computer
 */
export function downloadTarball(
  blob: Blob, 
  filename: string = 'seo-content-package.zip'
): void {
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = filename;
  document.body.appendChild(link);
  link.click();
  document.body.removeChild(link);
  
  URL.revokeObjectURL(url);
}

/**
 * Main function to create and download a complete package
 */
export async function buildAndDownloadPackage(
  ndjson: string,
  contentInfo: {
    topic?: string;
    keywords?: string[];
    contentGoal?: string;
    language?: string;
    title?: string;
  },
  options: TarballOptions = {}
): Promise<void> {
  try {
    const packageName = options.packageName || 
      `seo-${contentInfo.topic?.toLowerCase().replace(/[^a-z0-9]/g, '-') || 'content'}-${Date.now()}`;
    
    const tarball = await createTarballPackage(ndjson, contentInfo, {
      ...options,
      packageName
    });
    
    downloadTarball(tarball, `${packageName}.zip`);
  } catch (error) {
    console.error('Failed to build and download package:', error);
    throw error;
  }
} 